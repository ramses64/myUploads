in .NET Wpf i have implemented a prototype in order to make the drag and drop for the new outlook possible...for this i have used the COM solution...


using System;
using System.Windows;
using System.Windows.Interop;

namespace WpfApp1
{
    public partial class MainWindow : Window
    {
        private OutlookAsyncDropTarget _dropTarget;

        public MainWindow()
        {
            InitializeComponent();
        }

        protected override void OnSourceInitialized(EventArgs e)
        {
            base.OnSourceInitialized(e);

            // Get native window handle
            var hwnd = new WindowInteropHelper(this).Handle;

            _dropTarget = new OutlookAsyncDropTarget(hwnd, AddPathsToUi);

            int hr = Ole32.RegisterDragDrop(hwnd, _dropTarget);
            if (hr != 0)
            {
                MessageBox.Show($"RegisterDragDrop failed: 0x{hr:X8}");
            }
        }

        protected override void OnClosed(EventArgs e)
        {
            var hwnd = new WindowInteropHelper(this).Handle;
            Ole32.RevokeDragDrop(hwnd);
            base.OnClosed(e);
        }

        private void AddPathsToUi(string[] paths)
        {
            Dispatcher.Invoke(() =>
            {
                foreach (var p in paths)
                {
                    MyListBox.Items.Add(p);
                }
            });
        }
    }
}

OutlookAsyncDropTarget.cs:
using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Threading;

#region COM + PInvoke

[ComImport]
[Guid("00000122-0000-0000-C000-000000000046")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
interface IDropTarget
{
    void DragEnter([In] System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
                   uint grfKeyState, long pt, ref uint pdwEffect);

    void DragOver(uint grfKeyState, long pt, ref uint pdwEffect);

    void DragLeave();

    void Drop([In] System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
              uint grfKeyState, long pt, ref uint pdwEffect);
}

// IDataObjectAsyncCapability (used by Explorer for async/virtual file drops)
[ComImport]
[Guid("3D8B0590-F691-11D2-8EA9-006097DF5BD4")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
interface IDataObjectAsyncCapability
{
    void SetAsyncMode([MarshalAs(UnmanagedType.Bool)] bool fDoOpAsync);
    void GetAsyncMode([MarshalAs(UnmanagedType.Bool)] out bool pfIsOpAsync);
    void StartOperation(IBindCtx pbcReserved);
    void InOperation([MarshalAs(UnmanagedType.Bool)] out bool pfInAsyncOp);
    void EndOperation(int hResult, IBindCtx pbcReserved, uint dwEffects);
}

static class Ole32
{
    public const uint DROPEFFECT_COPY = 1;

    [DllImport("ole32.dll")]
    public static extern int RegisterDragDrop(IntPtr hwnd, IDropTarget pDropTarget);

    [DllImport("ole32.dll")]
    public static extern int RevokeDragDrop(IntPtr hwnd);

    [DllImport("ole32.dll")]
    public static extern int CoMarshalInterThreadInterfaceInStream(
        ref Guid riid,
        [MarshalAs(UnmanagedType.IUnknown)] object pUnk,
        out IStream ppStm);

    [DllImport("ole32.dll")]
    public static extern int CoGetInterfaceAndReleaseStream(
        IStream pStm,
        ref Guid riid,
        [MarshalAs(UnmanagedType.IUnknown)] out object ppv);

    [DllImport("ole32.dll")]
    public static extern int CoInitializeEx(IntPtr pvReserved, uint dwCoInit);

    [DllImport("ole32.dll")]
    public static extern void CoUninitialize();

    public const uint COINIT_APARTMENTTHREADED = 0x2;

    public static void ThrowIfFailed(int hr)
    {
        if (hr < 0) Marshal.ThrowExceptionForHR(hr);
    }
}

static class Shell32
{
    public const short CF_HDROP = 15;

    [DllImport("shell32.dll", CharSet = CharSet.Unicode)]
    public static extern uint DragQueryFile(IntPtr hDrop, uint iFile, char[]? lpszFile, uint cch);

    [DllImport("shell32.dll")]
    public static extern void DragFinish(IntPtr hDrop);
}

static class OleHelpers
{
    [DllImport("ole32.dll")]
    public static extern void ReleaseStgMedium(ref STGMEDIUM pmedium);
}

#endregion

public sealed class OutlookAsyncDropTarget : IDropTarget
{
    private readonly IntPtr _hwnd;
    private readonly Action<string[]> _onFiles;

    public OutlookAsyncDropTarget(IntPtr hwnd, Action<string[]> onFiles)
    {
        _hwnd = hwnd;
        _onFiles = onFiles;
    }

    public void DragEnter(System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
                          uint grfKeyState, long pt, ref uint pdwEffect)
    {
        pdwEffect = Ole32.DROPEFFECT_COPY;
    }

    public void DragOver(uint grfKeyState, long pt, ref uint pdwEffect)
    {
        pdwEffect = Ole32.DROPEFFECT_COPY;
    }

    public void DragLeave() { }

    public void Drop(System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
                     uint grfKeyState, long pt, ref uint pdwEffect)
    {
        pdwEffect = Ole32.DROPEFFECT_COPY;

        // 1) Check async capability
        IDataObjectAsyncCapability? asyncCap = TryGetAsyncCapability(pDataObj);

        // If supported, enable + start async operation (Explorer does this)
        if (asyncCap != null)
        {
            try
            {
                // Some sources require SetAsyncMode(true) first
                asyncCap.SetAsyncMode(true);

                // Start operation: after this, the source can "materialize" temp files
                asyncCap.StartOperation(null);
            }
            catch
            {
                // If StartOperation fails, we still try to get HDROP normally
                asyncCap = null;
            }
        }

        // 2) Marshal COM interfaces to worker thread (don’t pass COM objects directly!)
        var iidDataObj = typeof(System.Runtime.InteropServices.ComTypes.IDataObject).GUID;
        Ole32.ThrowIfFailed(Ole32.CoMarshalInterThreadInterfaceInStream(ref iidDataObj, pDataObj, out var stmDataObj));

        IStream? stmAsync = null;
        if (asyncCap != null)
        {
            var iidAsync = typeof(IDataObjectAsyncCapability).GUID;
            Ole32.ThrowIfFailed(Ole32.CoMarshalInterThreadInterfaceInStream(ref iidAsync, asyncCap, out stmAsync));
        }

        // 3) Worker STA thread: retrieve CF_HDROP once files exist
        var worker = new Thread(() =>
        {
            // Initialize COM in this thread as STA
            Ole32.ThrowIfFailed(Ole32.CoInitializeEx(IntPtr.Zero, Ole32.COINIT_APARTMENTTHREADED));
            try
            {
                // Resolve marshaled interfaces for THIS thread
                object dataObjUnk;
                Ole32.ThrowIfFailed(Ole32.CoGetInterfaceAndReleaseStream(stmDataObj, ref iidDataObj, out dataObjUnk));
                var dataObj = (System.Runtime.InteropServices.ComTypes.IDataObject)dataObjUnk;

                IDataObjectAsyncCapability? async2 = null;
                if (stmAsync != null)
                {
                    object asyncUnk;
                    var iidAsync = typeof(IDataObjectAsyncCapability).GUID;
                    Ole32.ThrowIfFailed(Ole32.CoGetInterfaceAndReleaseStream(stmAsync, ref iidAsync, out asyncUnk));
                    async2 = (IDataObjectAsyncCapability)asyncUnk;
                }

                try
                {
                    // NOTE: dragging EMAILS may show a New Outlook dialog.
                    // GetData can block until the user responds — but at least it blocks only this worker thread.
                    var paths = GetHDropFilePaths(dataObj);
                    if (paths.Length > 0)
                        _onFiles(paths);
                }
                finally
                {
                    // 4) Tell the source we’re done
                    if (async2 != null)
                    {
                        try
                        {
                            async2.EndOperation(0, null, Ole32.DROPEFFECT_COPY);
                        }
                        catch { /* ignore */ }
                    }
                }
            }
            finally
            {
                Ole32.CoUninitialize();
            }
        });

        worker.IsBackground = true;
        worker.SetApartmentState(ApartmentState.STA);
        worker.Start();

        // Return immediately from Drop (important!)
    }

    private static IDataObjectAsyncCapability? TryGetAsyncCapability(System.Runtime.InteropServices.ComTypes.IDataObject dataObj)
    {
        try
        {
            // COM cast attempt
            return (IDataObjectAsyncCapability)(object)dataObj;
        }
        catch
        {
            return null;
        }
    }

    private static string[] GetHDropFilePaths(System.Runtime.InteropServices.ComTypes.IDataObject dataObj)
    {
        var fmt = new FORMATETC
        {
            cfFormat = Shell32.CF_HDROP,
            dwAspect = DVASPECT.DVASPECT_CONTENT,
            lindex = -1,
            ptd = IntPtr.Zero,
            tymed = TYMED.TYMED_HGLOBAL
        };

        dataObj.GetData(ref fmt, out STGMEDIUM medium);

        try
        {
            if (medium.tymed != TYMED.TYMED_HGLOBAL || medium.unionmember == IntPtr.Zero)
                return Array.Empty<string>();

            IntPtr hDrop = medium.unionmember;

            uint count = Shell32.DragQueryFile(hDrop, 0xFFFFFFFF, null, 0);
            if (count == 0)
                return Array.Empty<string>();

            var result = new string[count];

            for (uint i = 0; i < count; i++)
            {
                uint len = Shell32.DragQueryFile(hDrop, i, null, 0);
                var buf = new char[len + 1];
                Shell32.DragQueryFile(hDrop, i, buf, (uint)buf.Length);
                result[i] = new string(buf).TrimEnd('\0');
            }

            Shell32.DragFinish(hDrop);
            return result;
        }
        finally
        {
            OleHelpers.ReleaseStgMedium(ref medium);
        }
    }
}