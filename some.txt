using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Threading;

#region COM + PInvoke

[ComImport]
[Guid("00000122-0000-0000-C000-000000000046")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
internal interface IDropTarget
{
    void DragEnter([In] System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
                   uint grfKeyState, long pt, ref uint pdwEffect);

    void DragOver(uint grfKeyState, long pt, ref uint pdwEffect);

    void DragLeave();

    void Drop([In] System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
              uint grfKeyState, long pt, ref uint pdwEffect);
}

// Async/virtual file drop support (New Outlook / Explorer behavior)
[ComImport]
[Guid("3D8B0590-F691-11D2-8EA9-006097DF5BD4")]
[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
internal interface IDataObjectAsyncCapability
{
    void SetAsyncMode([MarshalAs(UnmanagedType.Bool)] bool fDoOpAsync);
    void GetAsyncMode([MarshalAs(UnmanagedType.Bool)] out bool pfIsOpAsync);
    void StartOperation(IBindCtx pbcReserved);
    void InOperation([MarshalAs(UnmanagedType.Bool)] out bool pfInAsyncOp);
    void EndOperation(int hResult, IBindCtx pbcReserved, uint dwEffects);
}

internal static class Ole32
{
    public const uint DROPEFFECT_COPY = 1;

    [DllImport("ole32.dll")]
    public static extern int RegisterDragDrop(IntPtr hwnd, IDropTarget pDropTarget);

    [DllImport("ole32.dll")]
    public static extern int RevokeDragDrop(IntPtr hwnd);

    [DllImport("ole32.dll")]
    public static extern int CoMarshalInterThreadInterfaceInStream(
        ref Guid riid,
        [MarshalAs(UnmanagedType.IUnknown)] object pUnk,
        out IStream ppStm);

    [DllImport("ole32.dll")]
    public static extern int CoGetInterfaceAndReleaseStream(
        IStream pStm,
        ref Guid riid,
        [MarshalAs(UnmanagedType.IUnknown)] out object ppv);

    [DllImport("ole32.dll")]
    public static extern int CoInitializeEx(IntPtr pvReserved, uint dwCoInit);

    [DllImport("ole32.dll")]
    public static extern void CoUninitialize();

    [DllImport("ole32.dll")]
    public static extern int OleInitialize(IntPtr pvReserved);

    [DllImport("ole32.dll")]
    public static extern void OleUninitialize();

    public const uint COINIT_APARTMENTTHREADED = 0x2;

    public static void ThrowIfFailed(int hr)
    {
        if (hr < 0) Marshal.ThrowExceptionForHR(hr);
    }
}

internal static class Shell32
{
    public const short CF_HDROP = 15;

    [DllImport("shell32.dll", CharSet = CharSet.Unicode)]
    public static extern uint DragQueryFile(IntPtr hDrop, uint iFile, char[]? lpszFile, uint cch);

    [DllImport("shell32.dll")]
    public static extern void DragFinish(IntPtr hDrop);
}

internal static class User32
{
    [DllImport("user32.dll", CharSet = CharSet.Unicode)]
    public static extern short RegisterClipboardFormat(string lpszFormat);
}

internal static class Kernel32
{
    [DllImport("kernel32.dll")]
    public static extern IntPtr GlobalLock(IntPtr hMem);

    [DllImport("kernel32.dll")]
    [return: MarshalAs(UnmanagedType.Bool)]
    public static extern bool GlobalUnlock(IntPtr hMem);
}

internal static class OleHelpers
{
    [DllImport("ole32.dll")]
    public static extern void ReleaseStgMedium(ref STGMEDIUM pmedium);
}

#endregion

#region Classic Outlook virtual-file structs

// FILEGROUPDESCRIPTORW starts with a DWORD count, followed by FILEDESCRIPTORW[count]
[StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
internal struct FILEDESCRIPTORW
{
    public uint dwFlags;
    public Guid clsid;
    public int sizel_cx;
    public int sizel_cy;
    public int pointl_x;
    public int pointl_y;
    public uint dwFileAttributes;
    public FILETIME ftCreationTime;
    public FILETIME ftLastAccessTime;
    public FILETIME ftLastWriteTime;
    public uint nFileSizeHigh;
    public uint nFileSizeLow;

    [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)]
    public string cFileName;
}

#endregion

/// <summary>
/// Drop target that supports:
/// - New Outlook (async CF_HDROP via IDataObjectAsyncCapability)
/// - Classic Outlook (virtual files via FileGroupDescriptorW + FileContents)
/// - Normal file drops (CF_HDROP)
/// </summary>
[ComVisible(true)]
[ClassInterface(ClassInterfaceType.None)]
public sealed class OutlookAsyncDropTarget : IDropTarget
{
    private readonly IntPtr _hwnd;
    private readonly Action<string[]> _onFiles;

    private static readonly short CFSTR_FILEDESCRIPTORW = User32.RegisterClipboardFormat("FileGroupDescriptorW");
    private static readonly short CFSTR_FILECONTENTS = User32.RegisterClipboardFormat("FileContents");

    public OutlookAsyncDropTarget(IntPtr hwnd, Action<string[]> onFiles)
    {
        _hwnd = hwnd;
        _onFiles = onFiles;
    }

    public void DragEnter(System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
                          uint grfKeyState, long pt, ref uint pdwEffect)
    {
        pdwEffect = Ole32.DROPEFFECT_COPY;
    }

    public void DragOver(uint grfKeyState, long pt, ref uint pdwEffect)
    {
        pdwEffect = Ole32.DROPEFFECT_COPY;
    }

    public void DragLeave() { }

    public void Drop(System.Runtime.InteropServices.ComTypes.IDataObject pDataObj,
                     uint grfKeyState, long pt, ref uint pdwEffect)
    {
        pdwEffect = Ole32.DROPEFFECT_COPY;

        // 1) New Outlook: try to enable async mode + StartOperation
        IDataObjectAsyncCapability? asyncCap = TryGetAsyncCapability(pDataObj);
        if (asyncCap != null)
        {
            try
            {
                asyncCap.SetAsyncMode(true);
                asyncCap.StartOperation(null);
            }
            catch
            {
                asyncCap = null;
            }
        }

        // 2) Marshal COM interfaces to worker STA thread
        var iidDataObj = typeof(System.Runtime.InteropServices.ComTypes.IDataObject).GUID;
        Ole32.ThrowIfFailed(Ole32.CoMarshalInterThreadInterfaceInStream(ref iidDataObj, pDataObj, out var stmDataObj));

        IStream? stmAsync = null;
        if (asyncCap != null)
        {
            var iidAsync = typeof(IDataObjectAsyncCapability).GUID;
            Ole32.ThrowIfFailed(Ole32.CoMarshalInterThreadInterfaceInStream(ref iidAsync, asyncCap, out stmAsync));
        }

        // 3) Worker thread does the blocking GetData calls (New Outlook can show dialogs)
        var worker = new Thread(() =>
        {
            Ole32.ThrowIfFailed(Ole32.CoInitializeEx(IntPtr.Zero, Ole32.COINIT_APARTMENTTHREADED));
            try
            {
                // Resolve marshaled interfaces for this thread
                object dataObjUnk;
                Ole32.ThrowIfFailed(Ole32.CoGetInterfaceAndReleaseStream(stmDataObj, ref iidDataObj, out dataObjUnk));
                var dataObj = (System.Runtime.InteropServices.ComTypes.IDataObject)dataObjUnk;

                IDataObjectAsyncCapability? async2 = null;
                if (stmAsync != null)
                {
                    object asyncUnk;
                    var iidAsync = typeof(IDataObjectAsyncCapability).GUID;
                    Ole32.ThrowIfFailed(Ole32.CoGetInterfaceAndReleaseStream(stmAsync, ref iidAsync, out asyncUnk));
                    async2 = (IDataObjectAsyncCapability)asyncUnk;
                }

                try
                {
                    // Try CF_HDROP first (Explorer, normal files, New Outlook after async)
                    var paths = TryGetHDropFilePaths(dataObj);

                    // If CF_HDROP not available (often Classic Outlook mails), fallback to virtual files
                    if (paths.Length == 0)
                        paths = TryGetClassicOutlookVirtualFiles(dataObj);

                    if (paths.Length > 0)
                        _onFiles(paths);
                }
                finally
                {
                    // Tell source operation is finished (important for async sources)
                    if (async2 != null)
                    {
                        try { async2.EndOperation(0, null, Ole32.DROPEFFECT_COPY); }
                        catch { /* ignore */ }
                    }
                }
            }
            finally
            {
                Ole32.CoUninitialize();
            }
        });

        worker.IsBackground = true;
        worker.SetApartmentState(ApartmentState.STA);
        worker.Start();

        // Return immediately from Drop (keeps UI responsive)
    }

    private static IDataObjectAsyncCapability? TryGetAsyncCapability(System.Runtime.InteropServices.ComTypes.IDataObject dataObj)
    {
        try { return (IDataObjectAsyncCapability)(object)dataObj; }
        catch { return null; }
    }

    // -----------------------
    // CF_HDROP path (file list)
    // -----------------------
    private static string[] TryGetHDropFilePaths(System.Runtime.InteropServices.ComTypes.IDataObject dataObj)
    {
        var fmt = new FORMATETC
        {
            cfFormat = Shell32.CF_HDROP,
            dwAspect = DVASPECT.DVASPECT_CONTENT,
            lindex = -1,
            ptd = IntPtr.Zero,
            tymed = TYMED.TYMED_HGLOBAL
        };

        // Avoid throwing on Classic Outlook: check first
        int q = dataObj.QueryGetData(ref fmt);
        if (q != 0) return Array.Empty<string>();

        dataObj.GetData(ref fmt, out STGMEDIUM medium);
        try
        {
            if (medium.tymed != TYMED.TYMED_HGLOBAL || medium.unionmember == IntPtr.Zero)
                return Array.Empty<string>();

            IntPtr hDrop = medium.unionmember;

            uint count = Shell32.DragQueryFile(hDrop, 0xFFFFFFFF, null, 0);
            if (count == 0)
                return Array.Empty<string>();

            var result = new string[count];
            for (uint i = 0; i < count; i++)
            {
                uint len = Shell32.DragQueryFile(hDrop, i, null, 0);
                var buf = new char[len + 1];
                Shell32.DragQueryFile(hDrop, i, buf, (uint)buf.Length);
                result[i] = new string(buf).TrimEnd('\0');
            }

            // Optional: DragFinish is typically used by the drop target when it owns HDROP.
            Shell32.DragFinish(hDrop);

            return result;
        }
        finally
        {
            OleHelpers.ReleaseStgMedium(ref medium);
        }
    }

    // --------------------------------------------
    // Classic Outlook virtual files (MSG/EML) path
    // FileGroupDescriptorW + FileContents -> temp files
    // --------------------------------------------
    private static string[] TryGetClassicOutlookVirtualFiles(System.Runtime.InteropServices.ComTypes.IDataObject dataObj)
    {
        if (CFSTR_FILEDESCRIPTORW == 0 || CFSTR_FILECONTENTS == 0)
            return Array.Empty<string>();

        // 1) Names via FileGroupDescriptorW
        var fmtDesc = new FORMATETC
        {
            cfFormat = CFSTR_FILEDESCRIPTORW,
            dwAspect = DVASPECT.DVASPECT_CONTENT,
            lindex = -1,
            ptd = IntPtr.Zero,
            tymed = TYMED.TYMED_HGLOBAL
        };

        int q1 = dataObj.QueryGetData(ref fmtDesc);
        if (q1 != 0) return Array.Empty<string>();

        dataObj.GetData(ref fmtDesc, out STGMEDIUM mediumDesc);

        try
        {
            if (mediumDesc.tymed != TYMED.TYMED_HGLOBAL || mediumDesc.unionmember == IntPtr.Zero)
                return Array.Empty<string>();

            var fileNames = ParseFileGroupDescriptorW(mediumDesc.unionmember);
            if (fileNames.Length == 0)
                return Array.Empty<string>();

            var saved = new List<string>(fileNames.Length);

            for (int i = 0; i < fileNames.Length; i++)
            {
                // 2) Contents via FileContents (per-index)
                var fmtContents = new FORMATETC
                {
                    cfFormat = CFSTR_FILECONTENTS,
                    dwAspect = DVASPECT.DVASPECT_CONTENT,
                    lindex = i,
                    ptd = IntPtr.Zero,
                    tymed = TYMED.TYMED_ISTREAM // Outlook typically uses IStream
                };

                int q2 = dataObj.QueryGetData(ref fmtContents);
                if (q2 != 0)
                {
                    // Some cases may provide TYMED_HGLOBAL; you can add that if needed.
                    continue;
                }

                dataObj.GetData(ref fmtContents, out STGMEDIUM mediumContents);
                try
                {
                    if (mediumContents.tymed != TYMED.TYMED_ISTREAM || mediumContents.unionmember == IntPtr.Zero)
                        continue;

                    var stream = (IStream)Marshal.GetObjectForIUnknown(mediumContents.unionmember);

                    string safeName = SanitizeFileName(fileNames[i]);
                    if (string.IsNullOrWhiteSpace(Path.GetExtension(safeName)))
                    {
                        // Classic Outlook often uses .msg
                        safeName += ".msg";
                    }

                    string outPath = Path.Combine(
                        Path.GetTempPath(),
                        "outlook_drop_" + Guid.NewGuid().ToString("N") + "_" + safeName);

                    SaveComIStreamToFile(stream, outPath);
                    saved.Add(outPath);
                }
                finally
                {
                    OleHelpers.ReleaseStgMedium(ref mediumContents);
                }
            }

            return saved.ToArray();
        }
        finally
        {
            OleHelpers.ReleaseStgMedium(ref mediumDesc);
        }
    }

    private static string[] ParseFileGroupDescriptorW(IntPtr hGlobal)
    {
        IntPtr p = IntPtr.Zero;
        try
        {
            p = Kernel32.GlobalLock(hGlobal);
            if (p == IntPtr.Zero)
                return Array.Empty<string>();

            // First DWORD = number of items
            uint count = (uint)Marshal.ReadInt32(p);

            // FILEDESCRIPTORW array starts after 4 bytes
            IntPtr first = p + 4;
            int fdSize = Marshal.SizeOf<FILEDESCRIPTORW>();

            var names = new List<string>((int)count);
            for (int i = 0; i < count; i++)
            {
                IntPtr pi = first + i * fdSize;
                var fd = Marshal.PtrToStructure<FILEDESCRIPTORW>(pi);
                names.Add(fd.cFileName);
            }
            return names.ToArray();
        }
        finally
        {
            if (p != IntPtr.Zero)
                Kernel32.GlobalUnlock(hGlobal);
        }
    }

    private static void SaveComIStreamToFile(IStream comStream, string path)
    {
        Directory.CreateDirectory(Path.GetDirectoryName(path)!);

        using var fs = new FileStream(path, FileMode.Create, FileAccess.Write, FileShare.None);

        // Read in chunks using pcbRead
        const int BufSize = 64 * 1024;
        byte[] buffer = new byte[BufSize];

        IntPtr pcbRead = Marshal.AllocHGlobal(sizeof(int));
        try
        {
            while (true)
            {
                Marshal.WriteInt32(pcbRead, 0);
                comStream.Read(buffer, buffer.Length, pcbRead);
                int read = Marshal.ReadInt32(pcbRead);

                if (read <= 0)
                    break;

                fs.Write(buffer, 0, read);
            }
        }
        finally
        {
            Marshal.FreeHGlobal(pcbRead);
        }
    }

    private static string SanitizeFileName(string name)
    {
        foreach (char c in Path.GetInvalidFileNameChars())
            name = name.Replace(c, '_');
        return name;
    }
}